<!doctype html>
	<html lang="en">
	<head>
	    <title>Template (Three.js)</title>
	    <meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	</head>
	<body>

	<script src="js/three.min.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/KeyboardState.js"></script>
	<script src="js/THREEx.FullScreen.js"></script>
	<script src="js/THREEx.WindowResize.js"></script>

	<p>Upload an Image</p>
	<input id="user-image" type="file">
	<p> Make the image <input id="someInput" type="button" onClick="main()"></p>

	<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
	<script>
	/*
		Three.js "tutorials by example"
		Author: Lee Stemkoski
		Date: July 2013 (three.js v59dev)
	 */
	// MAIN
	// standard global variables
	var container, scene, camera, renderer, controls;
	var keyboard = new KeyboardState();
	var clock = new THREE.Clock();
	// custom global variables
	var mesh, mouseMesh;
	var mouse = {x: 0, y: 0};
	var imageWidth = 500;
	var imageHeight = 500;
	var linePoints = [];
	var coordsOnDown = [null,null];
	init();
	animate();
	// FUNCTIONS
	function init()
	{
		// SCENE
		scene = new THREE.Scene();
		// CAMERA
		var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
		var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
		camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
		scene.add(camera);
		camera.position.set(0,0,1500);//camera.position.set(0,1000,1000);
		camera.lookAt(scene.position);
		// RENDERER
		if ( Detector.webgl )
			renderer = new THREE.WebGLRenderer( {antialias:true} );
		else
			renderer = new THREE.CanvasRenderer();
		renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
		container = document.getElementById( 'ThreeJS' );
		container.appendChild( renderer.domElement );
		// EVENTS
		THREEx.WindowResize(renderer, camera);
		THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
		// CONTROLS
		controls = new THREE.OrbitControls( camera, renderer.domElement );

		// LIGHT
		var light = new THREE.PointLight(0xffffff);
		light.position.set(100,250,100);
		scene.add(light);

		// SKYBOX
		var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
		var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
		var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );

		scene.add(skyBox);

		////////////
		// CUSTOM //
		////////////

		// var geometry = new THREE.SphereGeometry( 30, 32, 16 );
		// var material = new THREE.MeshLambertMaterial( { color: 0x000088 } );
		// mesh = new THREE.Mesh( geometry, material );
		// mesh.position.set(0,40,0);
		// scene.add(mesh);
		var imageurl = 'fbox.png';

		var ImageGeometry = new THREE.PlaneGeometry(imageWidth, imageHeight, 10, 10);
		var uploadedImage = new THREE.TextureLoader().load(imageurl);
		//var texture = new THREE.CanvasTexture('js/rocks.jpg');
		//var ImageMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
		var ImageMaterial = new THREE.MeshBasicMaterial({map : uploadedImage, side: THREE.DoubleSide});//({color: 0xffff00});
		mesh = new THREE.Mesh( ImageGeometry, ImageMaterial );
		console.log(mesh);
		// mesh.position.set(0,100,0);

		scene.add( mesh );
		scene.updateMatrixWorld(true);


		// Create a circle around the mouse and move it
		// The sphere has opacity 0
		var mouseGeometry = 	new THREE.SphereGeometry( 10, 32, 32 );
		var mouseMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide } );
		mouseMesh = new THREE.Mesh(mouseGeometry, mouseMaterial);
		mouseMesh.position.z = -5;
		scene.add(mouseMesh);

		// When the mouse moves, call the given function
		document.addEventListener('mousemove', onMouseMove, false);

		document.addEventListener('mousedown', onMouseDown, false);
		document.addEventListener('mouseup', onMouseUp, false);
	}



	// Follows the mouse event
	function onMouseMove(event) {

		// Update the mouse variable
		event.preventDefault();
		mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
		mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

	 	// Make the sphere follow the mouse
		mouseMesh.position.copy(get3dPointZAxis());

		//console.log(mouse);

		// Make the sphere follow the mouse
	//	mouseMesh.position.set(event.clientX, event.clientY, 0);
	};
	function onMouseDown(event) {
		coordsOnDown = [mouse.x, mouse.y];
	};
	function onMouseUp(event) {
		// drag event not click
		if(coordsOnDown[0] != mouse.x || coordsOnDown[1] != mouse.y)
			return;

		linePoints.push(get3dPointZAxis());
		if(linePoints.length >= 2) {
			//create a blue LineBasicMaterial
			var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
			var geometry = new THREE.Geometry();
			geometry.vertices = extrapolatePoints(linePoints[0],linePoints[1]);
			var line = new THREE.Line( geometry, material );
			scene.add( line );
			renderer.render( scene, camera );
			var result = extrapolatePoints(linePoints[0],linePoints[1]);
			linePoints = result[0];
			var situation = result[1];
			// console.log(linePoints);
			// console.log(situation);
			subdivide (mesh, linePoints[0], linePoints[1], situation);
			linePoints = [];
		}
		
	};

	function subdivide (mesh , pt1, pt2, situation) {

		scene.remove(mesh);

		//coordinate automation
		
		var plane1 = new THREE.Geometry();
		var plane2 = new THREE.Geometry();
		//top left corner
		if (situation == 0) {
			var v1 = new THREE.Vector3(pt1.x, pt1.y);
			var v2 = new THREE.Vector3(pt2.x , pt2.y);
			var v3 = new THREE.Vector3(-250, 250);

			var w1 = new THREE.Vector3(pt1.x, pt1.y);
			var w2 = new THREE.Vector3(pt2.x , pt2.y);
			var w3 = new THREE.Vector3(250, 250);
			var w4 = new THREE.Vector3(250, -250);
			var w5 = new THREE.Vector3(-250, -250);
		//top right corner
		} else if (situation == 1) {
			var v1 = new THREE.Vector3(pt1.x, pt1.y);
			var v2 = new THREE.Vector3(pt2.x , pt2.y);
			var v3 = new THREE.Vector3(250, 250);

			var w1 = new THREE.Vector3(pt1.x, pt1.y);
			var w2 = new THREE.Vector3(pt2.x , pt2.y);
			var w3 = new THREE.Vector3(250, -250);
			var w4 = new THREE.Vector3(-250, -250);
			var w5 = new THREE.Vector3(-250, 250);
		//bottom right corner
		} else if (situation == 2) {
			var v1 = new THREE.Vector3(pt1.x, pt1.y);
			var v2 = new THREE.Vector3(pt2.x , pt2.y);
			var v3 = new THREE.Vector3(250, -250);

			var w1 = new THREE.Vector3(pt1.x, pt1.y);
			var w2 = new THREE.Vector3(pt2.x , pt2.y);
			var w3 = new THREE.Vector3(-250, -250);
			var w4 = new THREE.Vector3(-250, 250);
			var w5 = new THREE.Vector3(250, 250);
		//bottom left corner
		} else if (situation == 3) {
			var v1 = new THREE.Vector3(pt1.x, pt1.y);
			var v2 = new THREE.Vector3(pt2.x , pt2.y);
			var v3 = new THREE.Vector3(-250, -250);

			var w1 = new THREE.Vector3(pt2.x , pt2.y);
			var w2 = new THREE.Vector3(pt1.x, pt1.y);
			var w3 = new THREE.Vector3(-250, 250);
			var w4 = new THREE.Vector3(250, 250);
			var w5 = new THREE.Vector3(250, -250);
		//top bottom cut
		} else if (situation == 4) {
			var v1 = new THREE.Vector3(pt1.x, pt1.y);
			var v2 = new THREE.Vector3(250, 250);
			var v3 = new THREE.Vector3(250, -250);
			var v4 = new THREE.Vector3(pt2.x , pt2.y);

			var w1 = new THREE.Vector3(-250, 250);
			var w2 = new THREE.Vector3(pt1.x, pt1.y);
			var w3 = new THREE.Vector3(pt2.x , pt2.y);
			var w4 = new THREE.Vector3(-250, -250);
		//left right cut
		} 
		else if (situation == 5) {
			var v1 = new THREE.Vector3(pt1.x, pt1.y);
			var v2 = new THREE.Vector3(-250, 250);
			var v3 = new THREE.Vector3(250, 250);
			var v4 = new THREE.Vector3(pt2.x , pt2.y);

			var w1 = new THREE.Vector3(pt1.x, pt1.y);
			var w2 = new THREE.Vector3(pt2.x , pt2.y);
			var w3 = new THREE.Vector3(250, -250);
			var w4 = new THREE.Vector3(-250, -250);

		} 
		//for 3-1 divisions
		if (situation < 4) {
			plane1.vertices.push(v1);
			plane1.vertices.push(v2);
			plane1.vertices.push(v3);
			plane1.faces.push( new THREE.Face3( 0, 1, 2 ) );

			plane2.vertices.push(w1);
			plane2.vertices.push(w2);
			plane2.vertices.push(w3);
			plane2.vertices.push(w4);
			plane2.vertices.push(w5);	
		} else if (situation > 3) {
			plane1.vertices.push(v1);
			plane1.vertices.push(v2);
			plane1.vertices.push(v3);
			plane1.vertices.push(v4);
			plane1.faces.push( new THREE.Face3( 0, 1, 2 ) );
			plane1.faces.push( new THREE.Face3( 2, 3, 0 ) );

			plane2.vertices.push(w1);
			plane2.vertices.push(w2);
			plane2.vertices.push(w3);
			plane2.vertices.push(w4);
			plane2.faces.push( new THREE.Face3( 0, 1, 2 ) );
			plane2.faces.push( new THREE.Face3( 2, 3, 0 ) );
		}
		
		var material1 = new THREE.MeshBasicMaterial({color : 0xff0000, side: THREE.DoubleSide});
		var mesh = new THREE.Mesh( plane1, material1 );
		scene.add(mesh);

		var material2 = new THREE.MeshBasicMaterial({color : 0x0000ff, side: THREE.DoubleSide});

		if (situation < 4) {

			var vertices = plane2.vertices;
			var holes = [];
			var triangles, mesh;
			var geometry = new THREE.Geometry();

			geometry.vertices = vertices;
			triangles = THREE.ShapeUtils.triangulateShape( vertices, holes );

			for( var i = 0; i < triangles.length; i++ ){
		    	geometry.faces.push( new THREE.Face3( triangles[i][0], triangles[i][1], triangles[i][2] ));
			}
			mesh2 = new THREE.Mesh( geometry, material2 );
		} else {
			mesh2 = new THREE.Mesh( plane2, material2 );
		}
		
		
		scene.add(mesh2);

		// To Do
		/* 
		FOR TUESDAY
		3. Implement 1 SHAPE Folding
		*/
	}

	function extrapolatePoints(pt1, pt2) {
		var slope = (pt1.y - pt2.y)/(pt1.x - pt2.x);
		var y_a = Math.round(pt1.y + slope*(imageWidth/2 - pt1.x));
		var y_b = Math.round(pt1.y + slope*(-imageWidth/2 - pt1.x));

		var x_a = Math.round((imageHeight/2 - pt1.y)/slope + pt1.x);
		var x_b = Math.round((-imageHeight/2 - pt1.y)/slope + pt1.x);
		var newPts = [];
		//flags
		var left = 0;
		var right = 0;
		var top = 0;
		var bottom = 0;
		//point is on left
		if(Math.abs(y_b) <= imageHeight/2) {
			newPts.push({x: -250, y: y_b, z: 0});
			left = 1;
		}
		//point is on top
		if(Math.abs(x_a) <= imageWidth/2) {
			newPts.push({x: x_a, y: 250, z: 0});
			top = 1;
		}
		//point is on right
		if(Math.abs(y_a) <= imageHeight/2) {
			newPts.push({x: 250, y: y_a, z: 0});
			right = 1;
		}
		//point is on bottom
		if(Math.abs(x_b) <= imageHeight/2) {
			newPts.push({x: x_b, y: -250, z: 0});
			bottom = 1;
		}
		var sitation = 0;
		if (top + left == 2) {
			situation = 0;
		} else if (top + right == 2) {
			situation = 1;
		} else if (right + bottom == 2) {
			situation = 2;
		} else if (bottom + left == 2) {
			situation = 3;
		} else if (top + bottom == 2) {
			situation = 4;
		} else if (left + right == 2) {
			situation = 5;
		}
		var result = [newPts, situation]
		return result;
	}

	function get3dPointZAxis()
	{
	    var vector = new THREE.Vector3(mouse.x, mouse.y, -0.5);
		vector.unproject( camera );
		var dir = vector.sub( camera.position ).normalize();
		var distance = - camera.position.z / dir.z;
		var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );  
	    return pos;
	}


	function animate()
	{
	  	requestAnimationFrame( animate );
		render();
		update();
	}
	function update()
	{
		if ( keyboard.pressed("z") )
		{
			camera.position.set(0,2000,2000);
			camera.lookAt(scene.position);
			controls.update();
		}

		controls.update();

	}
	function render()
	{
		renderer.render( scene, camera );
	}
	</script>

	</body>
	</html>
